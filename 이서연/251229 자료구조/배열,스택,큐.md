# 자료구조: 배열, 스택, 큐

## 1. 배열(Array)

: 동일한 타입의 데이터를 연속된 메모리 공간에 저장하는 자료구조

<img width=70% alt="배열" src="https://github.com/user-attachments/assets/78740742-842c-4a7f-8e8f-8421860d94fd" />

**장점**

- 인덱스를 통한 직접 접근 → 읽기 속도가 매우 빠름
- 구현이 간단함

**단점**

- 크기가 고정되어 있음 → 생성 시, 크기 지정 필요
- 삽입/삭제 비효율 → 중간 데이터 삽입/삭제 시, 다른 요소들을 이동시켜야 해서 느림

**사용 사례)**

1. 순차적인 데이터를 저장하며 값보다는 순서가 중요한 경우
2. 다차원 데이터를 다룰 경우
3. 어떤 특정 요소를 빠르게 읽어야 할 경우
4. 데이터 사이즈가 자주 바뀌지 않으며 요소가 자주 추가되거나 삭제되지 않는 경우

---

## 2. 연결 리스트(Linked List)

: 각 노드가 데이터와 다음 노드의 위치를 가리키는 포인터로 구성된 선형 자료구조

<img width=70% alt="연결리스트" src="https://github.com/user-attachments/assets/f236d2a6-ee46-4433-996a-56cdd46fd5ea" />


**장점**

- 비연속적 메모리 사용 → 배열은 물리 메모리 주소가 연속적이지만, 연결 리스트는 물리 메모리 주소가 랜덤
- 동적 크기 조절 가능 → 크기를 자유롭게 변경할 수 있음
- 효율적인 삽입/삭제 → 포인터만 변경하면 되기에 빠르게 수정 가능
  
    <img width=70% alt="데이터 삽입" src="https://github.com/user-attachments/assets/b8800a17-7f88-4215-9132-8779151cd337" />
    
    데이터 삽입
  
    <img width=70% alt="데이터 삭제" src="https://github.com/user-attachments/assets/d40d1325-c40d-4d53-9639-bc7c5201922a" />
    
    데이터 삭제
    

**단점**

- 느린 조회 속도 → 특정 위치 접근 시, 순차적으로 순회해야 해서 느림
- 추가 메모리 필요 → 포인터를 저장하기 위한 추가 메모리 필요함

**종류**

<details>
<summary>단일 연결리스트(Single Linked List)</summary>
<br>
<div>
  : 포인터 값을 하나만 가지고 노드들을 길게 연결
    
  <img width=70% alt="단일 연결리스트" src="https://github.com/user-attachments/assets/efc89722-374b-4aee-b6ea-a71a8ae2a28b" />

</div>
</details>

<details>
<summary>이중 연결리스트(Doubly Linked List)</summary>
<br>
<div>
: 각 노드가 2개의 참조를 가짐 → 하나는 다음 노드, 하나는 이전 노드
    
<img width=70% alt="이중 연결리스트" src="https://github.com/user-attachments/assets/197cdf23-f1b8-44af-94e2-1111be8b9bf3" />

⇒ 단일 연결리스트는 단방향 탐색만 가능하지만, 이중 연결리스트는 지나간 노드를 다시 탐색할 수 있음
</div>
</details>

<details>
<summary>원형 연결리스트(Circular Linked List)</summary>
<br>
<div>
: 마지막 노드가 첫 번째 노드를 가리키는 단일 연결 리스트 → 리스트 순환 가능

<img width=70% alt="원형 연결리스트" src="https://github.com/user-attachments/assets/826ea9d0-eaa4-4553-93d0-d144869fd14c" />

⇒ head의 포인터가 마지막 노드를 가리키도록 구성하면 리스트의 끝에 노드를 삽입하는 연산이 효율적이게 됨
</div>
</details>

<details>
<summary>원형 이중 연결리스트(Doubly Circular Linked List)</summary>
<br>
<div>
  : 원형 리스트의 양방향 참조
  
  
  <img alt="원형 이중 연결리스트" src="https://github.com/user-attachments/assets/1a90c604-8501-4675-a7ed-7417fc935904" />

  ⇒ 원형 리스트의 역순환 불가능을 커버하지만, 구현하기가 매우 어렵다는 단점이 있음
</div>
</details>

**사용 사례)**

1. 데이터의 삽입/삭제가 잦고, 크기가 동적이어야 하는 경우

---

## 3. 스택 (Stack)

: 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 자료구조(후입선출)

<img width=90% alt="스택" src="https://github.com/user-attachments/assets/49cf53b6-76ac-4c7b-820d-137f3637f07c" />

**주요 연산**

- **삽입(push)**: 데이터를 스택 맨 위에 추가
- **삭제(pop)**: 스택 맨 위의 데이터를 제거하고 반환
- **조회(Peek/Top)** : 스택 맨 위 요소 반환(제거X)
- **비어있는지 확인(isEmpty)** : 스택이 비어있는지 확인

**장점**

- 빠른 삽입/삭제 가능
- 구현이 간단함(배열이나 연결 리스트로 구현 가능)

**단점**

- 중간 요소에 직접 접근 불가
- 검색에 비효율적

**사용 사례)**

1. 실행 취소, 웹 브라우저 뒤로가기 기능
2. 후위 표기법 연산, 문자열의 역순 출력, 괄호 검사 등
3. 함수 호출 스택(Call Stack)
4. 백트래킹, DFS(깊이 우선 탐색) 알고리즘

---

## 4. 큐 (Queue)

: 먼저 집어넣은 데이터가 먼저 나오는 선입선출 구조로 저장하는 선형 자료구조

<img width=50% alt="큐" src="https://github.com/user-attachments/assets/015e5464-8323-418b-b00d-67808b994a77" />

**주요 연산**

- **삽입(enqueue)**: 큐의 뒤에 데이터 추가
- **삭제(dequeue)**: 큐의 앞에서 데이터 제거하고 반환
- **조회(Peek/Front)**: 큐의 앞쪽 요소 반환(제거X)
- **비었는지 확인(isEmpty)**: 큐가 비어있는지 확인

**장점**

- 처리 순서가 보장됨
- 연결 리스트로 구현 시, 빠른 삽입/삭제 가능

**단점**

- 중간 요소에 직접 접근 불가
- 선형 배열로 구현 시, dequeue 연산이 비효율적

**종류**

<details>
<summary>선형 큐(Linear Queue)</summary>
<br>
<div>
  : 기본적인 큐의 형태
  
  ⇒ 크기가 제한되어 있고, 빈 공간을 사용하기 위해서는 모든 자료를 꺼내거나 자료를 한 칸씩 옮겨야 함
</div>
</details>

<details>
<summary>원형 큐(Circular Queue)</summary>
<br>
<div>
  : 선형 큐의 문제점을 보완하기 위한 형태
  

  <img alt="원형 큐" src="https://github.com/user-attachments/assets/785b9d12-e515-4e18-8cc2-40bdd6650f46" />
  
  
  ⇒ dequeue 연산 시, front가 원형으로 순회하며 이동(배열의 앞부분 재사용 가능)
</div>
</details>

<details>
<summary>우선순위 큐(Priority Queue)</summary>
<br>
<div>
  : 먼저 들어오는 데이터가 아니라, 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조
  
  <img alt="우선순위 큐" src="https://github.com/user-attachments/assets/beeaaa13-9b65-4221-98ac-429b5fb723a6" />
  

  ⇒ 일반적으로 힙을 이용해 구현(힙을 이용하면 최댓값, 최솟값을 찾아내는 연산이 빠름)
</div>
</details>

<details>
<summary>덱(Deque: Double-ended Queue)</summary>
<br>
<div>
  : 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조(큐의 일반화된 형태)
  

  <img alt="덱" src="https://github.com/user-attachments/assets/6059f079-7d0a-49af-867f-53e79427e03b" />
  

  ⇒ 큐와 스택의 기능을 모두 제공
</div>
</details>

**사용 사례)**

1. 작업/데이터를 순서대로 실행/사용하기 위해 대기시킬 때
    
    ex: CPU 스케줄링, 디스크 스케줄링
    
2. 서로 다른 쓰레드 또는 프로세스 사이에서 자료를 주고 받을 때 자료를 일시적으로 저장하는 용도(비동기 전송)
3. BFS(너비 우선 탐색) 알고리즘
4. 프린터 대기열
